
# 1. Concepts

1.1 求值模型：

* 正规序求值（normal-order evaluation）：完全展开然后归约
* 应用序求值（applicative-order evaluation）：先求值参数而后应用，解释器实际使用。

1.2 变量

bound variable: 约束变量
formal parameter: 形式参数

1.2.1 局部名:
* 约束变量：指形式参数，其名称改变，但过程定义的意义不会有任何改变。过程体（上下文）是这种变量的作用域(scoping)。
如此才能形成blackbox-abstraction
* 自由变量：非约束变量

1.2.2 内部定义：
* 词法作用域（lexical scoping）：内部过程中的自由变量实际上引用了外围过程定义中出现的约束变量（相当于局部的全局变量）.约束变量可作为内部定义中的自由变量使用。

```
;; x只在各自作用域中存在，且需每次传入。
(define (sqrt x)
	(sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
	(if (good-enough? guess x)
		guess
		(sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
	(< (abs (- (square guess) x)) 0.001))
(define (improve guess x)
	(average guess (/ x guess)))

;; x是sqrt中的约束变量，也是good-enough?,improve,sqrt-iter中的自由变量。
(define (sqrt x)
	(define (good-enough? guess)
		(< (abs (- (square guess) x)) 0.001))
	(define (improve guess)
		(average guess (/ x guess)))
	(define (sqrt-iter guess)
		(if (good-enough? guess x)
			guess
			(sqrt-iter (improve guess x) x)))
	(sqrt-iter 1.0 x))

;; 同名形参时
(define (ss x)
	(define (inner x)
		(+ 3 x)))
;; 内部为约束变量，参数变化需对过程不影响（需优先确保内部形参的约束性）
(define (ss x)
	(define (inner n)
		(+ 3 n)))
```

### 1.3 (#)为什么知道基本规则不知道如何编程

函数与过程（定义与指令）的矛盾：就是说明性语句（描述是什么，要做什么，比如平方根要符合以下定义：根号x=y，使y>=0且y*y=x）与行动性语句（如何去做，如用牛顿法求平方根）的矛盾

1.3.1 程序指导着过程的进行:
Procedures and the Processes They Generate

> We have now considered the elements of programming: We have used primitive arithmetic
operations, we have combined these operations, and we have abstracted these composite operations
by defining them as compound procedures. But that is not enough to enable us to say that we know
how to program. Our situation is analogous to that of someone who has learned the rules for how
the pieces move in chess but knows nothing of typical openings, tactics, or strategy. Like the novice
chess player,we don't yet know the common patterns of usage in the domain. We lack the
knowledge of which moves are worth making (which procedures are worth defining). We lack the
experience to predict the consequences of making a move (executing a procedure).

>The ability to visualize the consequences of the actions under consideration is crucial to becoming
an expert programmer, just as it is in any synthetic, creative activity. In becoming an expert
photographer, for example, one must learn how to look at a scene and know how dark each region
will appear on a print for each possible choice of exposure and development conditions. Only then
can one reason backward, planning framing, lighting, exposure, and development to obtain the
desired effects. So it is with programming, where we are planning the course of action to be taken
by a process and where we control the process by means of a program. To become experts, we must
learn to visualize the processes generated by various types of procedures. Only after we have
developed such a skill can we learn to reliably construct programs that exhibit the desired behavior.

已知（基本规则）：基本算术，对其组合，定义复合过程，对复合操作抽象
未知（实际常用模式）：典型应用模式，哪些过程值得定义，**对过程最终效果的准确预测**

1.3.2 计算过程
典型模式：描述计算过程的局部演化，计算过程的形状，即复杂度Θ（O）的形状与传入的参数的关系
时间复杂度正比于要执行的基本机器指令条数
空间复杂度正比于所寄存的内容数量

递归**过程**：语法形式上，说明过程的定义中（直接或间接）引用了过程本身
递归**计算过程**：指实际计算过程，递归过程也可产生迭代的计算过程。

尾递归：能在常量空间中执行迭代计算过程，即使它是用递归过程描述。

1.3.3 define

	(define obj num)
	(define obj (+ num1 num2))
	
	(define (proc num1 num2) (+ par1 par2))
	(define proc (lambda(par1 par2) (+ par1 par2)))

### 1.3.4 lambda
lambda:运行方式同普通函数，但由于匿名性，需直接执行并调用其后参数，（由于闭包特性）用lambda可描述**约束局部变量**的匿名过程

1.3.4.1 BNF 范式表达的上下文无关文法描述lambda
<expr> ::= <identifier>
<expr> ::= (λ <identifier> . <expr>)
<expr> ::= (<expr> <expr>)

1.3.4.2 嵌套

	((lambda(y)
	     ((lambda(x)
	     	 (+ x y))
			2))
	  5)

1.3.4.3 无限循环
	(define (infiniteloop)
		((lambda (x) (x x)) (lambda (x) (x x))))

	(define (proc f) ((lambda (x) (f (x x))) (lambda (x) (f (x x)))))
	(proc anyf)
	>>> (anyf ((lambda (x) (anyf (x x))) (lambda (x) (anyf (x x))))
	>>> (anyf (anyf ((lambda (x) (anyf (x x))) (lambda (x) (anyf (x x))))))
	
	finally: 
	(inner) == (f (inner)) == (f (f (inner))) == (f ... (f (inner)) ... )
	f(f(n)) = f(n)

1.3.4.4 let

(let ((a a1) (b b1)) (proc)) 相当于 ((lambda(a b) (proc)) (a1 b1))的简化形式。作为一种常用结构而提取出这一形式

	(define x 2)
	(define func
	  (let ((x 3) (y (+ x 6)))
	    (* x y)))
	;; equals to
	(define func
	  ((lambda (x y)
	     (* x y))
	   3
	   (+ x 6)))
	;; 结果为(* 3 (+ 2 6))

### 1.4 list始终以nil结尾,而序对结构cons并不一定以nil 结尾

	(cons 1 2)不作为list，不需要nil
	(list <a1> <a2> <a3>)
	等价于
	(cons <a1> (cons <a2> (cons <a3> nil)))

	(list (list 1 2) (list 3 4))	
	等价于
	(define cons-outer cons)
	(cons-outer ((cons 1 (cons 2 nil)) (cons-outer ((cons 3 (cons 4 nil)) nil)) 


打印输出 ((1 2) (3 4))

(cadr (list (list 1 2) (list 3 4)))获得(list 3 4),使用cadr而非cdr

[chapter1](#Eregister)

# 2. 数据结构

## A.subtitution model

1. *definition*：将一个复合过程应用于一些实际参数，就是在甬各个实际参数代换过程体里对应的形式参数后，求值这个过程体。

## B.enviroment model

#### 1. *definition*：

在将一个过程应用于一组实际参数时，将会建立起一个新环境，其中包含了将所有形式参数约束于对应的实际参数的框架，该框架的外围环境就是所用的那个过程的环境，随后就在这个新环境之下求值过程体。

#### 2. 建立新模型的原因：

由于引入赋值，变量不再只是一个值的名字，而是以某种方式指定了一个位置，可以储存值。这个位置将维持在环境中。

#### 3. 环境模型结构：
 
一个环境就是一系列的框架，框架是包含着一些约束的一个表格，约束将变量名关联到对应的值，且一个框架里，变量名字不能相同，一个变量至多只能有一个约束。
 
每个框架（除了全局环境）都包含一个指针，指向这一框架的外围环境。框架间通过环境指针相连，且只在当前环境的框架链中搜寻，如此才能迅速找到目标变量名（变量约束的值可能是其他环境，但并不影响）而不入侵其他分支，但多个环境指针可以指向同一框架,如此在求值时可以互通数据。

此时变量的值：一个环境中第一个所找到的相应变量名的框架中所约束的值。

	范例：

	框架一中保存着x:10,y:20
	框架二中保存着x:12,z:30
	框架三中保存着x:11, z:31
	框架四中保存着x:'最外围框架',y:21, w: 40，z:32
	EnviromentPointerA 指向框架1，
	EnviromentPointerB 指向框架2，
	框架一通过 EnviromentPointerC 指向框架三，
	框架三通过 EnviromentPointerE 指向框架四，
	框架二通过 EnviromentPointerD 指向框架四，

	此时环境A即框架一，框架三，框架四形成的整体
	此时环境C即框架三，框架四形成的整体

	在A中搜索z 会按框架一三四顺序搜索，在框架三中找到z，
	就会返回约束的值，不再向框架四搜索。

#### 4. The Rules for Evaluation
4.1. To evaluate a combination:

1. Evaluate the subexpressions of the combination.12
2. Apply the value of the operator subexpression to the values of the operand
subexpressions.

4.2. how procedures are created

> Procedures are created in one way only: by evaluating a lambda expression

* 求值lambda表达式产生的过程，是从lambda expression文本和求值lambda所在的环境中获取的。

* In the environment model of evaluation, a procedure is always a pair consisting of some code and a pointer to an environment

* In general,We also specify that defining a symbol using `define` creates a binding in the current environment frame
and assigns to the symbol the indicated value.

**for example**: 

	(define square
	  (lambda (x) (* x x)))

when `square` is evaluated in genv(global environment):
	
   

1. square is symbol maintained in global environment frame.
   // 'define' is in gEnv and so symbol square is stored in gEnv
2. square points(binds) to the procedure object.
3. the procedure object is a pair `(cons (lambda (x) (* x x)) pointer-to-globalenv)`.
   // proc pointer points to env where proc is evaluated,genv in this case
4. now symbol square refers to the procedure object.
	   
4.3 how procedures are applied

> To apply a procedure to arguments, **create a new environment** containing a frame that binds the parameters to the values of the arguments. The enclosing environment of this frame is the environment specified by the procedure. Now, within this new environment, evaluate the procedure body.

**for example**: (square 5)

	1. create a new env E1,param x:5 stored in E1
	2. run procbody (* x x) ,find symbol * in gEnv and get procedure *,find symbol x in E1
	3. substitute all the symbols to values found
	4. (* 5 5)  return result of procedure body,here 25

#### 4.4 The environment model of procedure application can be summarized by two rules:

* A procedure object is applied to a set of arguments by constructing a frame, binding the formal
parameters of the procedure to the arguments of the call, and then evaluating the body of the
procedure in the context of the new environment constructed. The new frame has as its enclosing
environment the environment part of the procedure object being applied.
* A procedure is created by evaluating a lambda expression relative to a given environment. The
resulting procedure object is a pair consisting of the text of the lambda expression and a pointer
to the environment in which the procedure was created.

Evaluating the expression `(set! <variable> <value>)` in some environment locates the binding of the variable in the environment
and changes that binding to indicate the new value.

4.5 The environment model explains the two key properties that
make local procedure definitions a useful technique for modularizing programs:

* The names of the local procedures do not interfere with names external to the enclosing
procedure, because the local procedure names will be bound in the frame that the procedure
creates when it is run, rather than being bound in the global environment.
* The local procedures can access the arguments of the enclosing procedure, simply by using
parameter names as free variables. (outer param as free rather than bind variable in inner proc).This is because the body of the local procedure is evaluated in
an environment that is subordinate to the evaluation environment for the enclosing procedure.

### 4.6 mutable structures

queue

(define make-queue (cons '() '())
(define (front queue) (car queue))
(define (pos queue) (cadr queue))
(define (pop-front elem queue) (let ((nq (append elem (car queue)))) (set-car! (cadr queue) nq)))



## C.事件驱动的模拟

### 1.并发(concurrent process)

``` lisp
(parallel-execute
  (lambda () (set! x (* x x))
  (lambda () (set! x (+ x 1))
```

x初始值10，建立2个并发计算进程P1,P2。x结果依赖P1，P2中各时间的**交错**情况，结果中1，2为非交错，3，4，5为交错

1. - 101：P1将x设为100，P2将x增加到101
2. - 121：同上
3. - 11：P2访问x，而后P1将x设置为100（此时P2访问到的值，对应的寄存器中存储的值依然为10），而后再P2设置x
4. - 100：同上
5. - 110：P2将10改为11的动作出现在P1两次访问x的值之间，两次访问以求值表达式（* x x)

**值为110的原因**：
计算时需依顺序找到环境变量中*，x，x对应的值。因此会访问2次x。由于现在访问所对应地址处的值而非值本身，x获得地址addr1中的值，第二个x与第一个x是同一变量，约束于同一地址，因此会再次获取addr1中的值。


### 2.流

``` lisp
(define (delay exp)
	(lambda () exp))
(define (force delayed-object)
	(delayed-object))

一对括号当中第一个符号即为操作符，因此(delayed-object)会运行自身而没有被操作符，道理同下
(define (nsquare number)
	(square number))

```

## E.register